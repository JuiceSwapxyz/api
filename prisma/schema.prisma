generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Central registry for wallet addresses
model User {
  id              String   @id @default(uuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  address         String   @unique
  ipAddressHash   String?

  // Relations
  ogCampaign      OgCampaignUser?

  @@index([address])
  @@index([ipAddressHash])
}

// OG Campaign participation tracking
// Stores campaign progress for users who opt in
model OgCampaignUser {
  userId            String    @id
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Swap task tracking
  // Actual swap details are stored in Ponder indexer
  swapsCompleted    Int       @default(0)

  // Social verification - Twitter and Discord account linking
  twitterVerifiedAt DateTime?
  twitterUserId     String?
  twitterUsername   String?
  discordVerifiedAt DateTime?
  discordUserId     String?
  discordUsername   String?

  @@index([twitterUserId])
  @@index([discordUserId])
}

// Twitter OAuth session storage (replaces in-memory storage)
// Sessions expire after 10 minutes for security
model TwitterOAuthSession {
  id            String   @id @default(uuid())
  state         String   @unique
  walletAddress String
  codeVerifier  String
  createdAt     DateTime @default(now())
  expiresAt     DateTime

  @@index([state])
  @@index([expiresAt])
}

// Discord OAuth session storage (replaces localStorage)
// Sessions expire after 10 minutes for security
// Note: Does not use PKCE (PUBLIC CLIENT = OFF, confidential client)
model DiscordOAuthSession {
  id            String   @id @default(uuid())
  state         String   @unique
  walletAddress String
  createdAt     DateTime @default(now())
  expiresAt     DateTime

  @@index([state])
  @@index([expiresAt])
}

// Bridge swap tracking for submarine, reverse, and chain swaps
model BridgeSwap {
  id                    String   @id
  userId                String   @map("user_id")
  type                  SwapType
  version               Int
  status                String

  // Assets and amounts
  assetSend             String   @map("asset_send")
  assetReceive          String   @map("asset_receive")
  sendAmount            BigInt   @map("send_amount")
  receiveAmount         BigInt   @map("receive_amount")
  date                  BigInt

  // Cryptographic identifiers
  preimage              String
  preimageHash          String   @map("preimage_hash")
  preimageSeed          String   @map("preimage_seed")

  // Key derivation
  keyIndex              Int      @map("key_index")
  claimPrivateKeyIndex  Int?     @map("claim_private_key_index")
  refundPrivateKeyIndex Int?     @map("refund_private_key_index")

  // Addresses
  claimAddress          String   @map("claim_address")
  address               String?
  refundAddress         String?  @map("refund_address")
  lockupAddress         String?  @map("lockup_address")

  // Transaction hashes
  claimTx               String?  @map("claim_tx")
  refundTx              String?  @map("refund_tx")
  lockupTx              String?  @map("lockup_tx")

  // Lightning / submarine specific
  invoice               String?  @db.Text
  acceptZeroConf        Boolean? @map("accept_zero_conf")
  expectedAmount        BigInt?  @map("expected_amount")

  // Reverse swap specific
  onchainAmount         BigInt?  @map("onchain_amount")
  timeoutBlockHeight    Int?     @map("timeout_block_height")

  // Chain swap specific (JSON details)
  claimDetails          Json?    @map("claim_details")
  lockupDetails         Json?    @map("lockup_details")

  // Additional metadata
  referralId            String?  @map("referral_id")
  chainId               Int?     @map("chain_id")

  // Timestamps
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([userId, status])
  @@index([userId, date(sort: Desc)])
  @@index([status])
  @@index([type])
  @@index([preimageHash])
  @@index([date(sort: Desc)])
  @@map("bridge_swaps")
}

enum SwapType {
  submarine
  reverse
  chain
}
